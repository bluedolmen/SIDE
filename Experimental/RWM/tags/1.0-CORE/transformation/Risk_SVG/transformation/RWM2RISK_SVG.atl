-- @atlcompiler atl2006
module RWM2Measure; -- Module Template
create OUT : SVG from IN : RWM;
helper context RWM!Goal def : priorityAsDouble : Real = 
    if (self.priority = #VeryHigh) then
      4.0
    else if (self.priority = #High) then
      3.0
    else if (self.priority = #Normal) then
      2.0
    else if (self.priority = #Low) then
      1.0
    else if (self.priority = #VeryLow) then
      0.0
    else
      2.0 --By default
	endif endif endif endif endif;

helper def : maxPriority() : Integer = 4;
helper def : unitary_coeff() : Real = 1.0; 
helper def : parent_coeff() : Integer = 1.0; 
helper def : child_coeff() : Integer = 0.5; 


helper context RWM!Goal def : getAllSubGoals() : Sequence(RWM!Goal) =
	Sequence{self}->union(self.subgoals->collect(goal | goal.getAllSubGoals())->flatten());

helper def : getRootGoals() : Sequence(RWM!Goal) =
    RWM!Goal->allInstances()->select(goal | RWM!Goal->allInstances()->select(g | g.subgoals->includes(goal))->size() = 0);

helper context RWM!Goal def : parent() : RWM!Goal =
    self.eContainer();

helper context RWM!Goal def : entitiesByGoal() : Sequence(RWM!Entity) =
    self.getAllSubGoals()->flatten()->collect(goal | goal.privilegeGroup)->select(elt | elt <> OclUndefined)->collect(pGroup | pGroup.privileges)->flatten()->collect(p | p.element)->asSet()->select(e | e.oclIsTypeOf(RWM!Entity));

helper context RWM!Goal def : attributesByGoal() : Sequence(RWM!Attribute) =
    self.getAllSubGoals()->flatten()->collect(goal | goal.privilegeGroup)->select(elt | elt <> OclUndefined)->collect(pGroup | pGroup.privileges)->flatten()->collect(p | p.element)->asSet()->select(e | e.oclIsTypeOf(RWM!Attribute));

helper context RWM!Goal def : unitaryRiskV1 : Real =
    self.priorityAsDouble / thisModule.maxPriority();

helper context RWM!Goal def : unitaryRiskV2 : Real =
    let couv : Real =
        ((self.entitiesByGoal().size() / RWM!Entity->allInstances()->size()) + (self.attributesByGoal().size() / RWM!Attribute->allInstances()->size()))*0.5
    in
    	0.5*(couv + self.unitaryRiskV1);

helper context RWM!Goal def : risk() : Real = 
    if (not(self.eContainer().oclIsTypeOf(RWM!Goal))) then
    	self.unitaryRiskV2
    else
        let vself : Real =
            thisModule.unitary_coeff() * self.unitaryRiskV2
        in
        let vparent : Real =
            thisModule.parent_coeff() * self.parent().unitaryRiskV2
        in
        let vchilds : Real =
            if (self.subgoals->size() = 0) then
            	0
           	else
           	    ((self.subgoals->collect(g | g.unitaryRiskV2)->sum())/(self.parent().subgoals->collect(g | g.subgoals)->flatten()->collect(g | g.unitaryRiskV2)->select(v | v.oclIsTypeOf(Real))->sum()))*thisModule.child_coeff()
           	endif
        in
        	(vself + vparent + vchilds) / (thisModule.unitary_coeff() + thisModule.parent_coeff() + thisModule.child_coeff())
    endif;

rule RequirementsDefinition {
    from s : RWM!RequirementsDefinition
    to t : SVG!Svg (
            namespace <- 'http://www.w3.org/2000/svg',
            version <- '1.1',
            baseProfile <- 'full',
            width <- 
            	let
            		max_set : Sequence(Integer) = RWM!VisualElement->allInstances()->collect(el | el.x + el.width)->asSet()
            	in
            	let 
            		max : Integer = max_set->select(v | max_set->select(v2 | v2 > v)->size() = 0)->first()
                in
                  (max+10)->toString() + 'px',
            height <- 
            	let
            		max_set : Sequence(Integer) = RWM!VisualElement->allInstances()->collect(el | el.y + el.height)->asSet()
            	in
            	let 
            		max : Integer = max_set->select(v | max_set->select(v2 | v2 > v)->size() = 0)->first()
                in
                  (max+10)->toString() + 'px'
        )
        do {
            thisModule.svg <- t;
        }
}

rule Goal {
    from s : RWM!Goal
    to t_left : SVG!Rect (
		root <- thisModule.svg,
		position <- t_p_left,
		size <- t_s_left,
		stroke <- 'stroke-width:1;stroke:rgb(0,0,0);',
		fill <- 'fill:rgb('+(s.unitaryRiskV1*255)->toString()+','+((1-s.unitaryRiskV1)*255)->toString()+',0);'
    ),
    t_right : SVG!Rect (
		root <- thisModule.svg,
		position <- t_p_right,
		size <- t_s_right,
		stroke <- 'stroke-width:1;stroke:rgb(0,0,0);',
		fill <- 'fill:rgb('+(s.risk()*255)->toString()+','+((1-s.risk())*255)->toString()+',0);'
    ),
    t_p_left : SVG!Coordinates (
        x <- s.x,
        y <- s.y
    ),
    t_s_left : SVG!Dimension (
        width <- s.width.div(2),
        height <- s.height
    ),
    t_p_right : SVG!Coordinates (
        x <- (s.x + s.width/2).round(),
        y <- s.y
    ),
    t_s_right : SVG!Dimension (
        width <- s.width.div(2),
        height <- s.height
    ),
    t_text : SVG!Text (
		root <- thisModule.svg,
		position <- t_text_p,
		content <- s.name,
		fontSize <- '10px',
		textAlign <- 'center'
    ),
    t_text_p : SVG!Coordinates (
        x <- s.x + 5,
        y <- (s.y + s.height/2 + 5).round()
    )
}

rule ChildGoal extends Goal {
    from s : RWM!Goal (s.eContainer().oclIsTypeOf(RWM!Goal))
    to p : SVG!Path (
		root <- thisModule.svg,
		d <-
			let parent : RWM!Goal =  s.parent()
			in
			let x_start : Integer = parent.x + parent.width/2 in
			let y_start : Integer = parent.y + parent.height/2 in
			let x_end : Integer = s.x + s.width/2 in
			let y_end : Integer = s.y + s.height/2 in
				'M ' + x_start.toString()+ ',' +y_start.toString() + ' L ' + x_end.toString() + ',' + y_end.toString()
    )
}